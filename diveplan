#!/usr/bin/python3

import csv
import sys
import getopt
import datetime
import math
import time
import itertools
from docx.enum.style import WD_STYLE_TYPE
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.table import WD_TABLE_ALIGNMENT
from docx import Document 
from docx.shared import Pt 

#pip install python-docx

#Data from data.marine.ie/Dataset/Details/20955

def parsetime(time):
    return datetime.datetime.strptime(time, "%Y-%m-%dT%H:%M:%SZ")

def daterange(start, end):
    if start <= end:
        for n in range((end - start).days + 1):
            yield start + datetime.timedelta(n)

def white_strand_start(level):
    max_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 1) 
    min_level = -math.inf
    return level < max_level and level > min_level 

def white_strand_end(level):
    max_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 1) 
    min_level = -math.inf
    return level < max_level and level > min_level 

def ballyvaughan_start(level):
    max_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 0) 
    min_level = rule_of_twelfths(max_neap_high_tide, min_neap_low_tide, 1.5) 
    return level < max_level and level > min_level 

def ballyvaughan_end(level):
    max_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 0) 
    min_level = rule_of_twelfths(max_neap_high_tide, min_neap_low_tide, 1.5) 
    return level < max_level and level > min_level 

def gleninagh_start(level):
    max_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 1) 
    min_level = -math.inf
    return level < max_level and level > min_level 

def gleninagh_end(level):
    max_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 1) 
    min_level = -math.inf
    return level < max_level and level > min_level 
    
def quilty_start(level):
    min_level = rule_of_twelfths(max_neap_high_tide, min_neap_low_tide, 0) 
    max_level = math.inf
    return level < max_level and level > min_level 

def quilty_end(level):
    max_level = math.inf
    min_level = -math.inf
    return level < max_level and level > min_level 

def kilkee_start(level):
    max_level =  math.inf
    min_level = rule_of_twelfths(max_spring_high_tide, min_spring_low_tide, 5) 
    return level < max_level and level > min_level 

def kilkee_end(level):
    max_level = math.inf 
    min_level = -math.inf
    return level < max_level and level > min_level 

def doolin_start(level):
    max_level = math.inf
    min_level = -math.inf
    return level < max_level and level > min_level 

def doolin_end(level):
    max_level = math.inf 
    min_level = -math.inf
    return level < max_level and level > min_level 
    
def rule_of_twelfths(high, low, time): # time in hours relative to high
     range = float(high)- float(low)
     return float(low) + (range * (math.cos(math.pi * time/6) + 1 ) / 2)
                                         
class DivePlan(object):
    def __init__(self):
       self.document = Document()
       style = self.document.styles['Normal']
       font = style.font
       font.name = "Arial"
       font.size = Pt(10)
      
       styles = self.document.styles
       style = styles.add_style('Bold Style', WD_STYLE_TYPE.PARAGRAPH) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True

       style = styles.add_style('Bold Underline Style', WD_STYLE_TYPE.PARAGRAPH) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True
       font.underline = True

       style = styles.add_style('Bold Large Style', WD_STYLE_TYPE.PARAGRAPH) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True
       font.size = Pt(16)

       style = styles.add_style('Bold Underline Large Style', WD_STYLE_TYPE.PARAGRAPH) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True
       font.underline = True
       font.size = Pt(16)

       styles = self.document.styles
       style = styles.add_style('Bold StyleC', WD_STYLE_TYPE.CHARACTER) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True

       style = styles.add_style('Bold Underline StyleC', WD_STYLE_TYPE.CHARACTER) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True
       font.underline = True

       style = styles.add_style('Bold Large StyleC', WD_STYLE_TYPE.CHARACTER) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True
       font.size = Pt(16)

       style = styles.add_style('Bold Underline Large StyleC', WD_STYLE_TYPE.CHARACTER) 
       style.base_style = styles['Normal']
       font = style.font
       font.bold = True
       font.underline = True
       font.size = Pt(16)
       table = self.document.add_table(10,2)

       cell = table.cell(0,0)
       p = cell.add_paragraph("Burren Sub Aqua Club\n")
       p.alignment = WD_ALIGN_PARAGRAPH.CENTER
       p.add_run("SNORKEL / DIVE PLAN\n")
       r = p.add_run("Month 2016") 
       r.style = self.document.styles['Bold Underline Large StyleC']

       p.style = self.document.styles['Bold Large Style']
       cell = table.cell(0,1)
       p = cell.add_paragraph() 
       r = p.add_run()
       r.add_picture('Burren-Sub-Aqua-Logo.jpg')


       c1 = table.cell(1,0) 
       c2 = table.cell(1,1) 
       c1.merge(c2)
       p = c1.add_paragraph("A kitted brief should take place ")
       r = p.add_run("15 mins")
       r.style = self.document.styles['Bold Underline StyleC']
       p.add_run(" before dive departure times")
       p.alignment = WD_ALIGN_PARAGRAPH.CENTER
      
       c1 = table.cell(2,0) 
       c2 = table.cell(2,1) 
       c1.merge(c2)
       self.dive_table = c1.add_table(1,8)
       self.dive_table.style = 'Table Grid'
       self.dive_table.alignment = WD_TABLE_ALIGNMENT.CENTER


       c1 = table.cell(3,0) 
       c2 = table.cell(3,1) 
       c1.merge(c2)

       p = c1.add_paragraph("Note: Please check with the DOD if in doubt about conditions, particularly with strong westerly winds.")
       p.style = self.document.styles['Bold Underline Style']
       p.alignment = WD_ALIGN_PARAGRAPH.CENTER

       c1.add_paragraph("Note: The dives at 09.00am on Sundays are for Club Diver** and up only, unless announced otherwise")
       p = c1.add_paragraph()
       r = p.add_run("All members: ")
       r.style = self.document.styles['Bold Underline StyleC']
       p.add_run("if you intend to dive, please text the relevant DOD by 18.00 on the preceding Friday (Sunday dives), or by 18.00 hours on the preceding Monday (Wednesday dives).  This allows DODs time to plan dives and make alternative arrangements if necessary.  Divers who text after the deadline will be assigned a dive only if space allows, to be treated on a first come, first served basis")
       p = c1.add_paragraph()
       r = p.add_run("DODs / Dry Coxns: ")
       r.style = self.document.styles['Bold Underline StyleC']
       p.add_run("if you are unavailable for your slot, please arrange a swap yourself with someone else in good time and text me the new arrangement.  Please text members of a DOD change to avoid confusion.")
       p = c1.add_paragraph()
       r = p.add_run("DODs / Dry Coxns: ")
       r.style = self.document.styles['Bold Underline StyleC']
       p.add_run("please communicate and check with James in good time that he is available to bring the boat to the dive site, and make alternative arrangements if necessary.")
       c1.add_paragraph("Members undertaking dives outside the dive plan should inform me; otherwise, they cannot be regarded as club dives for insurance purposes.")
       p = c1.add_paragraph("LIFE JACKETS MUST BE WORN ON THE BOAT")
       p.style = self.document.styles['Bold Underline Style']
       p.alignment = WD_ALIGN_PARAGRAPH.CENTER
       p = c1.add_paragraph("DODs: ALL DIVE LOGS MUST BE FILLED AND RETAINED.  PLEASE PLACE IN THE JEEP WHEN COMPLETED.")
       p.style = self.document.styles['Bold Style']
       p.alignment = WD_ALIGN_PARAGRAPH.CENTER

       c1 = table.cell(4,0) 
       c2 = table.cell(4,1) 
       c1.merge(c2)
       p = c1.add_paragraph("DOD/COXN Telephone Numbers:")
       p.style = self.document.styles['Bold Underline Style']
       p.alignment = WD_ALIGN_PARAGRAPH.CENTER

       c1 = table.cell(5,0) 
       c2 = table.cell(5,1) 
       c1.merge(c2)
       t = c1.add_table(4,2)
       t.style = 'Table Grid'
       c1 = t.cell(0,0) 
       c1.add_paragraph("Cormac McMahon - 086 8119068")
       c1 = t.cell(1,0) 
       c1.add_paragraph("James McMahon - 087 6898005")
       c1 = t.cell(2,0) 
       c1.add_paragraph("Mary O'Donnell - 087 9845073")
       c1 = t.cell(3,0) 
       c1.add_paragraph("Alex McMahon - 086 8795949")
       c1 = t.cell(0,1) 
       c1.add_paragraph("Tadhg O'Brien - 086 8180044")
       c1 = t.cell(1,1) 
       c1.add_paragraph("John Underhill - 087 7537738")
       c1 = t.cell(2,1) 
       c1.add_paragraph("Caroline Hartigan - 087 2334748")
       c1 = t.cell(3,1) 
       c1.add_paragraph("Mark Gray - 085 7127021")

    def add_dive(self, date, tide_list, levels):
       tides = [tide for tide in tide_list if tide.isNear(date)]
       high = [tide for tide in tides if tide.isNear(date) and tide.get_type() == "High"]
       low = [tide for tide in tides if tide.isNear(date) and tide.get_type() == "Low"]
       level = levels[date]

       site = ""
       if white_strand_start(float(level)):
           site += "White Strand\n"
       if gleninagh_start(float(level)):
           site += "Gleninagh Pier\n"
       if ballyvaughan_start(float(level)):
           site += "Ballyvaughan Pier\n"
       if quilty_start(float(level)):
           site += "Quilty\n"
       if doolin_start(float(level)):
           site += "Doolin\n"
       if kilkee_start(float(level)):
           site += "Kilkee\n"

       if high:
           high_time = high[0].get_time().strftime("%H:%M") 
           high_level = high[0].get_level() 
       else:
           high_time = ""
           high_level = ""

       if low:
           low_time = low[0].get_time().strftime("%H:%M") 
           low_level = low[0].get_level() 
       else:
           low_time = ""
           low_level = ""

       return self.add_row(date, site, "", "", "{}\n{}m".format(high_time, high_level), "{}\n{}m".format(low_time, low_level))
       
    def add_row(self, time, venue, dod, coxn, hw, lw): 
       r = self.dive_table.add_row()
       r.cells[0].text = time.strftime("%a")
       r.cells[1].text = time.strftime("%b\n%d")
       r.cells[2].text = venue
       r.cells[3].text = time.strftime("%H:%M")
       r.cells[4].text = dod 
       r.cells[5].text = coxn 
       r.cells[6].text = hw 
       r.cells[7].text = lw 
       print("Day:", time.strftime("%a"), ",Date:", time.strftime("%b %d"), ",Venue:", venue.replace('\n',' '), ",Time:", time.strftime("%H:%M"), ",HW:", hw.replace('\n',' '), ",LW:", lw.replace('\n',' ')) 
       return r
       
    def add_blank(self): 
       r = self.dive_table.add_row()
       return r
       
    def add_header(self, day, date, venue, time, dod, coxn, hw, lw): 
       r = self.dive_table.add_row()
       r.style = self.document.styles['Bold Underline Style']
       r.cells[0].text = day 
       r.cells[1].text = date 
       r.cells[2].text = venue
       r.cells[3].text = time 
       r.cells[4].text = dod 
       r.cells[5].text = coxn 
       r.cells[6].text = hw 
       r.cells[7].text = lw 
       
    def publish(self):
       self.document.save('demo.docx')   

class Tide(object):
      def __init__(self, level, time, type):
            self.level = level
            self.time = time
            self.type = type
      def get_time(self):
            return self.time
      def get_type(self):
            return self.type
      def get_level(self):
            return self.level
      def __str__(self):
            return self.get_type()+"("+self.get_level()+"):"+self.time.strftime("%H:%M")
      def isNear(self, t):
            delta = t - self.time
            return delta < datetime.timedelta(hours=6)

class TideParse(object):
      def __init__(self, level, time):
            self.levels = []
            self.times = []
            self.increasing = None 
            self.max = level
            self.min = level
            self.levels.append(level)
            self.times.append(parsetime(time))      

      def add(self, level, time):
            self.levels.append(level)
            self.times.append(parsetime(time))
            return self.parse()

      def get_time(self, level):
            return self.times[self.levels.index(level)] 

      def parse(self):
           if (self.max != max(self.levels)):
                  #Values increasing, rising tide
                  self.increasing = True
                  self.max = max(self.levels) 
                  return None
           if (self.min != min(self.levels)):
                  #Values decreasing, falling tide
                  self.increasing = False
                  self.min = min(self.levels) 
                  return None 
           if (self.max != max(self.levels)) & (self.min != min(self.levels)):
                  raise Exception("minmax error")
           if (self.max == max(self.levels)) & (self.min == min(self.levels)):
                  #Possible turning point
                  if (self.increasing == True) & (self.levels[-1] < self.levels[-2]):
                      t = self.get_time(self.max) 
                      return Tide(self.max, t, "High")
                  elif (self.increasing == False) & (self.levels[-1] > self.levels[-2]):
                      t = self.get_time(self.min) 
                      return Tide(self.min, t, "Low")
                  else:
                      return None

max_spring_high_tide = 0
max_neap_high_tide = 0
min_spring_low_tide = 0 
min_neap_low_tide = 0 

# First we read the csv file and parse all the high/low tides
def main(argv):

# Handle command line arguments
    data = 'data.csv'
    publish = False
    syntax = 'diveplan -d <inputfile> -p s <dd/mm/yy> -e <dd/mm/yy>'
    start = None
    end = None
    
    try:
        opts, args = getopt.getopt(argv,"hd:ps:e:",["data="])
    except getopt.GetoptError:
        print(syntax)
        sys.exit(2)
    for opt, arg in opts:
        if opt == '-h':
            print (syntax)
            sys.exit()
        elif opt in ("-p", "--publish"):
            publish = True
        elif opt in ("-d", "--data"):
            data = arg
        elif opt in ("-s", "--start"):
            start = arg
        elif opt in ("-e", "--end"):
            end = arg
            
    if not start:
        print(syntax)
        sys.exit(2)
    if not end:
        print(syntax)
        sys.exit(2)

    start = datetime.datetime.strptime(start, "%d/%m/%y")
    end = datetime.datetime.strptime(end, "%d/%m/%y")
              
    tide_list = []
    levels = {}
                                             
# Parse tide data
    with open(data, 'r') as csvfile:
        tidedata = csv.DictReader(csvfile)
        row = next(tidedata)
 
        tc = TideParse(row['Water_Level'], row['time'])
        levels.update({parsetime(row['time']) : row['Water_Level']}) 
        
        for row in tidedata:
            tide = tc.add(row['Water_Level'], row['time'])
            levels.update({parsetime(row['time']) : row['Water_Level']}) 
 
            if tide:
                tide_list.append(tide)
                tc = TideParse(row['Water_Level'], row['time'])
 
    high_tides = [tide for tide in tide_list if tide.get_type() == "High"]
    low_tides = [tide for tide in tide_list if tide.get_type() == "Low"]

    max_spring_high_tide = max(tide.get_level() for tide in high_tides)
    max_neap_high_tide = min(tide.get_level() for tide in high_tides)
    min_spring_low_tide = min(tide.get_level() for tide in low_tides)
    min_neap_low_tide = max(tide.get_level() for tide in low_tides)
    print("Max Spring high: ", max_spring_high_tide)
    print("Max Neap high:   ", max_neap_high_tide)
    print("Min Spring low:  ", min_spring_low_tide)
    print("Min Neap Low:    ", min_neap_low_tide)
 
    diveplan = DivePlan()
    diveplan.add_header("Day", "Date", "Venue", "Time", "DoD", "Coxn", "HW", "LW")
     
    for date in daterange( start, end ):
        if date.weekday() == 6:
            date = date.replace(hour = 9)
            r1 = diveplan.add_dive(date, tide_list, levels)

            date = date.replace(hour = 12)
            r2 = diveplan.add_dive(date, tide_list, levels)
                
            for id in [0,1,2,6,7]: 
                c1 = r1.cells[id]
                text = c1.text
                c2 = r2.cells[id]
                c1 = c1.merge(c2)
                c1.text = text
            diveplan.add_blank()

        if date.weekday() == 2:
            date = date.replace(hour = 19)
            r1 = diveplan.add_dive(date, tide_list, levels)
            diveplan.add_blank()
 
    if publish:
        diveplan.publish()




if __name__ == "__main__":
   main(sys.argv[1:])
